#!/usr/bin/env python

# Continuously builds a latex document, refreshing it only when it has changed.

# What makes this different from latexmk, is that it just continually builds in
# the background, and refreshes to the latest copy _after each build_. This
# means you get to see the latest copy, even if there are 3 or 4 iterations
# left to go to make it perfect.

# However, it won't just constantly rebuild while there are no changes.

# It does _not_ attempt to do an error parser. rubber-info does that
# spectacularly. However, it will copy the log file, so that its not constantly
# changing, and only update it to the latest.

import subprocess
import shutil
import time 
import os
import hashlib

def get_input_files(base):
	lines = open(base + ".fls", "r").readlines ()
	result = set()
	for line in lines:
		(before, _, after) = line.rstrip().partition (" ")
		if before == "INPUT" and after[0] != "/":
			result.add (after)

	return result

filename = "thesis.tex"
base = "thesis"


latex = ["pdflatex", "-recorder", "-interaction=nonstopmode", filename]
bibtex = ["bibtex", base]

timestamps = {}
md5s = {}


while (True):

	files = get_input_files (base)

	# Keep checking the files until a timestamp changes
	build = False
	while build == False:
		for f in files:

			# First check the timestamp
			t = os.path.getmtime(f)
			if t > timestamps.get (f, 0):
#				print f + " has a newer timestamp"
				timestamps[f] = t

				# Check if it has actually changed
				m = hashlib.md5( open( f, "r" ).read()).hexdigest()
				if m != md5s.get (f, ""):
					print f + " has changed"
					md5s[f] = m
					build = True


	# Now build it


	# We dont care about outputs or exit code
	subprocess.call (latex, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	subprocess.call (bibtex, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	print "Rebuilt at " + time.ctime()

	# Copy it to refresh the viewer
	shutil.copy ("thesis.pdf", "t.pdf")
	shutil.copy ("thesis.log", "t.log")


